// Generated by AvatarShaderLibrary 242d0d331a49

#ifdef ENABLE_enableEnvironmentMap
  static const bool enableEnvironmentMap = true;
#else
  static const bool enableEnvironmentMap = false;
#endif


struct avatar_Light
{
    float3 direction;
    float range;
    float3 color;
    float intensity;
    float3 position;
    float innerConeCos;
    float outerConeCos;
    float shadowTerm;
    int type;
};

struct avatar_FragOptions
{
    bool enableNormalMapping;
    bool enableAlphaToCoverage;
    bool enableEnvironmentMap;
    bool enableRimLight;
    bool enablePreviewColorRamp;
    bool enableDebugRender;
    bool enableSkin;
    bool enableEyeGlint;
    bool enableHair;
    bool enableShadows;
};

struct avatar_SkinMaterial
{
    float3 subsurface_color;
    float3 skin_ORM_factor;
};

struct avatar_HairMaterial
{
    float3 subsurface_color;
    float scatter_intensity;
    float3 specular_color_factor;
    float specular_shift_intensity;
    float specular_white_intensity;
    float specular_white_roughness;
    float specular_color_intensity;
    float specular_color_offset;
    float specular_color_roughness;
    float anisotropic_intensity;
    float diffused_intensity;
    float normal_intensity;
    float specular_glint;
    float ao_intensity;
    float flow_angle;
    float shift;
    float blend;
    float aniso_blend;
};

struct avatar_RimLightMaterial
{
    float intensity;
    float bias;
    float3 color;
    float transition;
    float start;
    float end;
};

struct avatar_Material
{
    float3 base_color;
    float alpha;
    float exposure;
    float metallic;
    float occlusion;
    float roughness;
    float thickness;
    float ambient_diffuse_factor;
    float ambient_specular_factor;
    float eye_glint_factor;
    float eye_glint_color_factor;
    avatar_SkinMaterial skin;
    avatar_HairMaterial hair_material;
    avatar_RimLightMaterial rim_light_material;
    float ramp_selector;
    int color_selector_lod;
};

struct avatar_Matrices
{
    float4x4 objectToWorld;
    float3x3 worldToObject;
    float4x4 viewProjection;
};

struct avatar_TangentSpace
{
    float3 normal;
    float3 tangent;
    float3 bitangent;
};

struct avatar_Geometry
{
    float3 camera;
    float3 positionInClipSpace;
    float3 positionInWorldSpace;
    float3 normal;
    avatar_TangentSpace tangentSpace;
    float2 texcoord_0;
    float2 texcoord_1;
    float4 color;
    float4 ormt;
    float normalScale;
    float3 worldViewDir;
    float lod;
};

struct avatar_AmbientLighting
{
    float3 diffuse;
    float3 specular;
};

struct avatar_FragmentInput
{
    avatar_FragOptions options;
    avatar_Matrices matrices;
    avatar_Geometry geometry;
    avatar_Material material;
    int lightsCount;
    avatar_Light lights[8];
    float3 ambient_color;
    int debugMode;
};

struct avatar_FragmentOutput
{
    float4 color;
    float3 p_specular;
    float3 p_diffuse;
    float3 a_specular;
    float3 a_diffuse;
    float3 subSurfaceColor;
    uint alphaCoverage;
};

struct avatar_HemisphereNormalOffsets
{
    float3 nn;
    float3 bb;
    float3 tt;
    float3 lv1;
    float3 lv2;
    float3 lv3;
};

struct avatar_SpecularData
{
    float3 directional_light_color;
    float range_attentuation;
    float spot_attenuation;
    float _distance;
    float3 point_to_light;
    float actualCos;
    float3 l;
    float3 h;
    float roughPow2;
    float roughPow4;
    float invRoughPow4;
    float NdotV;
};



uniform sampler2D u_BaseColorSampler;
uniform sampler2D u_MetallicRoughnessSampler;
uniform sampler2D u_NormalSampler;
uniform float u_NormalScale;
uniform int u_MipCount;
uniform int Debug;
uniform float u_Exposure;
uniform float u_MetallicFactor;
uniform float u_OcclusionStrength;
uniform float u_RoughnessFactor;
uniform float u_ThicknessFactor;
uniform float3 u_SubsurfaceColor;
uniform float3 u_SkinORMFactor;
uniform float u_EyeGlintFactor;
uniform float u_EyeGlintColorFactor;
uniform float3 u_HairSubsurfaceColor;
uniform float u_HairScatterIntensity;
uniform float3 u_HairSpecularColorFactor;
uniform float u_HairSpecularShiftIntensity;
uniform float u_HairSpecularWhiteIntensity;
uniform float u_HairSpecularColorIntensity;
uniform float u_HairSpecularColorOffset;
uniform float u_HairRoughness;
uniform float u_HairColorRoughness;
uniform float u_HairAnisotropicIntensity;
uniform float u_HairSpecularNormalIntensity;
uniform float u_HairDiffusedIntensity;
uniform float u_HairSpecularGlint;
uniform float u_RimLightIntensity;
uniform float u_RimLightBias;
uniform float3 u_RimLightColor;
uniform float u_RimLightTransition;
uniform float u_RimLightStartPosition;
uniform float u_RimLightEndPosition;
uniform sampler2D u_ColorGradientSampler;
uniform int u_RampSelector;

static float4 _21;



struct FragmentOutput
{
    float4 _21 : COLOR0;
};


avatar_Geometry avatar_zeroGeometry()
{
    avatar_Geometry geometry;
    geometry.camera = 0.0f.xxx;
    geometry.positionInWorldSpace = 0.0f.xxx;
    geometry.positionInClipSpace = 0.0f.xxx;
    geometry.texcoord_0 = 0.0f.xx;
    geometry.texcoord_1 = 0.0f.xx;
    geometry.color = 0.0f.xxxx;
    geometry.normalScale = 0.0f;
    geometry.tangentSpace.normal = 0.0f.xxx;
    geometry.tangentSpace.tangent = 0.0f.xxx;
    geometry.tangentSpace.bitangent = 0.0f.xxx;
    geometry.normal = 0.0f.xxx;
    return geometry;
}

avatar_HairMaterial avatar_zeroHairMaterial()
{
    avatar_HairMaterial material;
    material.subsurface_color = 0.0f.xxx;
    material.scatter_intensity = 0.0f;
    material.specular_color_factor = 0.0f.xxx;
    material.specular_shift_intensity = 0.0f;
    material.specular_white_intensity = 0.0f;
    material.specular_white_roughness = 0.0f;
    material.specular_color_intensity = 0.0f;
    material.specular_color_offset = 0.0f;
    material.specular_color_roughness = 0.0f;
    material.anisotropic_intensity = 0.0f;
    material.diffused_intensity = 0.0f;
    material.normal_intensity = 0.0f;
    material.specular_glint = 0.0f;
    material.ao_intensity = 0.0f;
    material.flow_angle = 0.0f;
    material.shift = 0.0f;
    material.blend = 0.0f;
    material.aniso_blend = 0.0f;
    return material;
}

avatar_Material avatar_zeroMaterial()
{
    avatar_Material material0;
    material0.base_color = 0.0f.xxx;
    material0.alpha = 0.0f;
    material0.exposure = 0.0f;
    material0.metallic = 0.0f;
    material0.occlusion = 0.0f;
    material0.roughness = 0.0f;
    material0.thickness = 0.0f;
    material0.skin.subsurface_color = 0.0f.xxx;
    material0.skin.skin_ORM_factor = 0.0f.xxx;
    material0.eye_glint_factor = 0.0f;
    material0.eye_glint_color_factor = 0.0f;
    material0.hair_material = avatar_zeroHairMaterial();
    material0.ramp_selector = 0.0f;
    material0.color_selector_lod = 0;
    return material0;
}

avatar_Matrices avatar_zeroMatrices()
{
    avatar_Matrices matrices;
    matrices.objectToWorld = float4x4(0.0f.xxxx, 0.0f.xxxx, 0.0f.xxxx, 0.0f.xxxx);
    matrices.worldToObject = float3x3(0.0f.xxx, 0.0f.xxx, 0.0f.xxx);
    matrices.viewProjection = float4x4(0.0f.xxxx, 0.0f.xxxx, 0.0f.xxxx, 0.0f.xxxx);
    return matrices;
}

avatar_FragOptions avatar_zeroOptions()
{
    avatar_FragOptions options;
    options.enableNormalMapping = false;
    options.enableAlphaToCoverage = false;
    options.enableEnvironmentMap = false;
    options.enableRimLight = false;
    options.enableSkin = false;
    options.enableEyeGlint = false;
    options.enableHair = false;
    options.enableShadows = false;
    return options;
}

avatar_Light avatar_zeroLight()
{
    avatar_Light light;
    light.direction = 0.0f.xxx;
    light.range = 0.0f;
    light.color = 0.0f.xxx;
    light.intensity = 0.0f;
    light.position = 0.0f.xxx;
    light.innerConeCos = 0.0f;
    light.outerConeCos = 0.0f;
    light.shadowTerm = 1.0f;
    light.type = 0;
    return light;
}

avatar_FragmentInput avatar_zeroFragmentInput()
{
    avatar_FragmentInput i;
    i.ambient_color = 0.0f.xxx;
    i.geometry = avatar_zeroGeometry();
    i.material = avatar_zeroMaterial();
    i.matrices = avatar_zeroMatrices();
    i.debugMode = 0;
    i.options = avatar_zeroOptions();
    for (int idx = 0; idx < 8; idx++)
    {
        i.lights[idx] = avatar_zeroLight();
    }
    return i;
}

bool avatar_WithinRange(float idChannel, float lowBound, float highBound)
{
    return (idChannel > (lowBound - 0.001953125f)) && (idChannel < (highBound + 0.001953125f));
}

bool avatar_UseSkin(float idChannel)
{
    return avatar_WithinRange(idChannel, 0.0078125f, 0.015625f);
}

bool avatar_UseEyeGlint(float idChannel)
{
    return avatar_WithinRange(idChannel, 0.125f, 0.25f);
}

bool avatar_IsOfType(float idChannel, float subMeshType)
{
    return avatar_WithinRange(idChannel, subMeshType, subMeshType);
}

bool avatar_UseHair(float idChannel)
{
    return avatar_IsOfType(idChannel, 0.03125f);
}

avatar_FragOptions getFragOptions(float subMeshIdChannel)
{
    avatar_FragOptions options = avatar_zeroOptions();
    options.enableNormalMapping = enableNormalMapping;
    options.enableAlphaToCoverage = enableAlphaToCoverage;
    options.enableEnvironmentMap = enableEnvironmentMap;
    options.enableRimLight = enableRimLight;
    if (true)
    {
        options.enableSkin = enableSkin && avatar_UseSkin(subMeshIdChannel);
        options.enableEyeGlint = enableEyeGlint && avatar_UseEyeGlint(subMeshIdChannel);
        options.enableHair = enableHair && avatar_UseHair(subMeshIdChannel);
    }
    else
    {
        options.enableSkin = enableSkin;
        options.enableEyeGlint = enableEyeGlint;
        options.enableHair = enableHair;
    }
    options.enablePreviewColorRamp = enablePreviewColorRamp;
    options.enableDebugRender = enableDebugRender;
    return options;
}

float3 calculateBitangent(avatar_TangentSpace tangentSpace)
{
    return normalize(cross(tangentSpace.normal, tangentSpace.tangent));
}

float LINEARtoSRGB(float color)
{
    return pow(color, 0.4545454680919647216796875f);
}

float3 computeViewDir(float3 camera, float3 position)
{
    return normalize(position - camera);
}

void AppSpecificPreManipulation(inout avatar_FragmentInput i);

avatar_FragmentOutput avatar_zeroFragmentOutput()
{
    avatar_FragmentOutput o;
    o.color = 0.0f.xxxx;
    o.p_specular = 0.0f.xxx;
    o.p_diffuse = 0.0f.xxx;
    o.a_specular = 0.0f.xxx;
    o.a_diffuse = 0.0f.xxx;
    o.subSurfaceColor = 0.0f.xxx;
    o.alphaCoverage = 255u;
    return o;
}

float saturate(float x)
{
    return clamp(x, 0.0f, 1.0f);
}

float computeNdotV(float3 normal, float3 world_view_dir)
{
    return saturate(-dot(normal, world_view_dir));
}

avatar_SpecularData avatar_fillInSpecularData(avatar_Geometry geometry, avatar_Light light, avatar_Material material, avatar_FragOptions options)
{
    avatar_SpecularData sd;
    sd.directional_light_color = ((light.color * (1.0f / material.exposure)) * 0.3183098733425140380859375f) * light.intensity;
    sd.point_to_light = -light.direction;
    sd.range_attentuation = 0.0f;
    sd.spot_attenuation = 0.0f;
    sd._distance = length(sd.point_to_light);
    if (light.type != 0)
    {
        sd.point_to_light = light.position - geometry.positionInWorldSpace;
        if (light.range <= 0.0f)
        {
            sd.range_attentuation = 1.0f / pow(sd._distance, 2.0f);
        }
        else
        {
            sd.range_attentuation = max(min(1.0f - pow(sd._distance / light.range, 4.0f), 1.0f), 0.0f) / pow(sd._distance, 2.0f);
        }
    }
    if (light.type != 2)
    {
        sd.actualCos = dot(normalize(light.direction), normalize(-sd.point_to_light));
        if (sd.actualCos > light.outerConeCos)
        {
            if (sd.actualCos < light.innerConeCos)
            {
                sd.spot_attenuation = smoothstep(light.outerConeCos, light.innerConeCos, sd.actualCos);
            }
        }
    }
    sd.l = normalize(sd.point_to_light);
    sd.h = normalize(sd.l - geometry.worldViewDir);
    if (light.range <= 0.0f)
    {
        sd.range_attentuation = 1.0f / pow(sd._distance, 2.0f);
    }
    else
    {
        sd.range_attentuation = max(min(1.0f - pow(sd._distance / light.range, 4.0f), 1.0f), 0.0f) / pow(sd._distance, 2.0f);
    }
    sd.roughPow2 = material.roughness * material.roughness;
    sd.roughPow4 = sd.roughPow2 * sd.roughPow2;
    sd.invRoughPow4 = 1.0f - sd.roughPow4;
    sd.NdotV = computeNdotV(geometry.normal, geometry.worldViewDir);
    return sd;
}

float3 avatar_computeSpecular(avatar_Geometry geometry, avatar_Light light, avatar_Material material, avatar_FragOptions options)
{
    float LIGHTSIZE = 0.5f;
    float sumAreaLight = 0.0f;
    avatar_SpecularData sd = avatar_fillInSpecularData(geometry, light, material, options);
    if (material.roughness < 0.20000000298023223876953125f)
    {
        LIGHTSIZE = lerp(0.0500000007450580596923828125f, 0.5f, saturate((material.roughness - 0.100000001490116119384765625f) * 10.0f));
    }
    float stepSize = LIGHTSIZE / 5.0f;
    float _3522 = sd.NdotV;
    float _3527 = sd.invRoughPow4;
    float _3530 = sd.roughPow2;
    float ggxCommon = sqrt(((_3522 * _3522) * _3527) + _3530);
    float t;
    for (int i = 0; i < 5; i++)
    {
        for (int j = 0; j < 5; j++)
        {
            float3 worldSpaceLightDir = sd.l;
            worldSpaceLightDir.x += ((float(i) - 2.5f) * stepSize);
            worldSpaceLightDir.y += ((float(j) - 2.5f) * stepSize);
            float3 h = normalize(worldSpaceLightDir - geometry.worldViewDir);
            float NdotL = saturate(dot(worldSpaceLightDir, geometry.normal));
            float NdotH = saturate(dot(geometry.normal, h));
            float ggx = (NdotL * ggxCommon) + (_3522 * sqrt(((NdotL * NdotL) * _3527) + _3530));
            if (ggx > 0.0f)
            {
                t = 0.5f / ggx;
            }
            else
            {
                t = 0.0f;
            }
            ggx = t;
            float t0 = 1.0f / (1.0f - ((NdotH * NdotH) * _3527));
            sumAreaLight += ((((NdotL * t0) * t0) * sd.roughPow4) * ggx);
        }
    }
    return (sd.directional_light_color * (sumAreaLight / 25.0f)) * 1.5f;
}

float3 avatar_computeDiffuse(avatar_Geometry geometry, avatar_Light light, avatar_Material material, out float3 diffuseWrap)
{
    float3 directional_light_color = ((light.color * (1.0f / material.exposure)) * 0.3183098733425140380859375f) * light.intensity;
    float NdotL = dot(geometry.normal, normalize(-light.direction));
    diffuseWrap = directional_light_color * saturate(smoothstep(-0.64999997615814208984375f, 1.0f, NdotL));
    return directional_light_color * saturate(smoothstep(-0.1500000059604644775390625f, 1.0f, NdotL));
}

float4 mod289(float4 x)
{
    return x - (floor(x * 0.00346020772121846675872802734375f) * 289.0f);
}

float4 perm(float4 x)
{
    return mod289(((x * 34.0f) + 1.0f.xxxx) * x);
}

float _noise(float3 p)
{
    float3 a = floor(p);
    float3 d = p - a;
    float3 d_1 = (d * d) * (3.0f.xxx - (d * 2.0f));
    float4 b = a.xxyy + float4(0.0f, 1.0f, 0.0f, 1.0f);
    float4 c = perm(perm(b.xyxy).xyxy + b.zzww) + a.zzzz;
    float _2028 = d_1.z;
    float4 o3 = (frac(perm(c + 1.0f.xxxx) * 0.024390242993831634521484375f) * _2028) + (frac(perm(c) * 0.024390242993831634521484375f) * (1.0f - _2028));
    float _2040 = d_1.x;
    float2 o4 = (o3.yw * _2040) + (o3.xz * (1.0f - _2040));
    float _2052 = d_1.y;
    return (o4.y * _2052) + (o4.x * (1.0f - _2052));
}

float3 computeSpecularHighlight(float anisotropicIntensity, float roughness, float3 L, float3 E, float3 t, float3 tangent, float3 bitangent, float offset)
{
    float3 H = 0.0f.xxx;
    float kspec = 0.0f;
    float kexp = 0.0f;
    float3 spec = 0.0f.xxx;
    float3 t_1 = normalize(t + (bitangent * offset));
    if (anisotropicIntensity > 0.0f)
    {
        float3 isotropicH = normalize(E + L);
        H = normalize((E + L) - (tangent * dot(E + L, tangent)));
        H = normalize(lerp(isotropicH, H, anisotropicIntensity.xxx));
        kspec = dot(H, t_1);
        kexp = 1.0f / ((roughness * roughness) + 0.001000000047497451305389404296875f);
    }
    else
    {
        H = normalize(E + L);
        kspec = dot(t_1, H);
        kexp = 3.0f / ((roughness * roughness) + 0.001000000047497451305389404296875f);
    }
    if (kspec > (-0.001000000047497451305389404296875f))
    {
        float specular = pow(max(0.0f, kspec), kexp);
        spec = 0.0f.xxx + specular.xxx;
    }
    return spec;
}

float3 computeHairSpecular(avatar_FragmentInput i, float3 lightVector, float3x3 hairCoordinateSystem, float anisotropicBlend)
{
    float3 E = -i.geometry.worldViewDir;
    float3 L = normalize(-lightVector);
    float anisotropy = lerp(0.0f, i.material.hair_material.anisotropic_intensity, anisotropicBlend);
    float localOffset = ((i.material.hair_material.specular_shift_intensity * (i.material.hair_material.shift - 0.5f)) * anisotropicBlend) + (((_noise(float3(i.geometry.texcoord_0.x, i.geometry.texcoord_0.y, float2(0.0f, 1.0f).x) * 2000.0f.xxx) * 2.0f) - 1.0f) * 0.00999999977648258209228515625f);
    return ((computeSpecularHighlight(anisotropy, i.material.hair_material.specular_white_roughness, L, E, hairCoordinateSystem[0], hairCoordinateSystem[2], hairCoordinateSystem[1], localOffset) * i.material.hair_material.specular_white_intensity) + ((computeSpecularHighlight(anisotropy, i.material.hair_material.specular_color_roughness, L, E, hairCoordinateSystem[0], hairCoordinateSystem[2], hairCoordinateSystem[1], i.material.hair_material.specular_color_offset + localOffset) * i.material.hair_material.specular_color_factor) * i.material.hair_material.specular_color_intensity)) * i.material.hair_material.ao_intensity;
}

float3 blendPunctualSpecularWithHair(float3 punctualSpec, float3 hairPunctualSpec, float hairBlend)
{
    return lerp(punctualSpec, hairPunctualSpec, hairBlend.xxx);
}

float3 blendSubSurfaceColorWithHair(float3 hairSubsurfaceColor, float3 skinSubsurfaceColor, float hairBlend)
{
    return lerp(hairSubsurfaceColor, skinSubsurfaceColor, hairBlend.xxx);
}

avatar_HemisphereNormalOffsets avatar_computeHemisphereNormalOffsets(avatar_FragmentInput i)
{
    avatar_HemisphereNormalOffsets hno;
    hno.nn = i.geometry.tangentSpace.normal * 0.707099974155426025390625f;
    hno.tt = i.geometry.tangentSpace.tangent * 0.3535499870777130126953125f;
    hno.bb = i.geometry.tangentSpace.bitangent * 0.612348616123199462890625f;
    hno.lv1 = hno.nn + (hno.tt * 2.0f);
    hno.lv2 = (hno.nn + hno.bb) - hno.tt;
    hno.lv3 = (hno.nn - hno.bb) - hno.tt;
    return hno;
}

float3 saturate(float3 v)
{
    return clamp(v, 0.0f.xxx, 1.0f.xxx);
}

float3 avatar_addRimLight(avatar_Geometry geometry, avatar_Material t)
{
    float multiplier = 1.0f;
    avatar_Material t_1 = t;
    float gradient = (atan2(dot(geometry.normal, float3(1.0f, 0.0f, 0.0f)), dot(geometry.normal, float3(0.0f, 1.0f, 0.0f))) / 6.283185482025146484375f) + 0.5f;
    if (gradient < t.rim_light_material.start)
    {
        multiplier = 0.0f;
    }
    if ((gradient >= t.rim_light_material.start) && (gradient <= t.rim_light_material.end))
    {
        multiplier = smoothstep(t.rim_light_material.start, t.rim_light_material.start + t.rim_light_material.transition, gradient);
        multiplier *= smoothstep(t.rim_light_material.end, t.rim_light_material.end - t.rim_light_material.transition, gradient);
    }
    if (gradient > t.rim_light_material.end)
    {
        multiplier = 0.0f;
    }
    if (t.rim_light_material.bias == 0.0f)
    {
        t_1.rim_light_material.bias = 0.001000000047497451305389404296875f;
    }
    return (t_1.rim_light_material.color * t_1.rim_light_material.intensity) * (pow(clamp(1.0f - computeNdotV(geometry.normal, geometry.worldViewDir), 0.0f, 1.0f), 1.0f / t_1.rim_light_material.bias) * multiplier);
}

float dither17b(float2 svPosition, float frameIndexMod4)
{
    return frac(dot(float3(svPosition, frameIndexMod4), float3(0.117647059261798858642578125f, 0.4117647111415863037109375f, 1.35294115543365478515625f)));
}

uint alphaToCoverage(float alpha)
{
    uint Coverage = 0u;
    if (alpha > 0.0f)
    {
        Coverage = 136u;
    }
    if (alpha > 0.25f)
    {
        Coverage = 153u;
    }
    if (alpha > 0.5f)
    {
        Coverage = 221u;
    }
    if (alpha > 0.75f)
    {
        Coverage = 255u;
    }
    return Coverage;
}

uint coverageFromMaskMSAA4(float t, float2 svPos, bool dither)
{
    float t_1 = t;
    if (dither)
    {
        t_1 = t - (dither17b(svPos, 0.0f) / 4.0f);
    }
    else
    {
        t_1 -= 0.125f;
    }
    return alphaToCoverage(t_1);
}

uint avatar_calculateAlphaCoverage(avatar_FragmentInput i, float3 positionInScreenSpace)
{
    bool _return = false;
    uint _returnValue;
    if (!i.options.enableAlphaToCoverage)
    {
        _return = true;
        _returnValue = 255u;
    }
    if (!_return)
    {
        _return = true;
        _returnValue = coverageFromMaskMSAA4(i.material.alpha, positionInScreenSpace.xy, true);
    }
    return _returnValue;
}

void AppSpecificPostManipulation(avatar_FragmentInput i, inout avatar_FragmentOutput o);

float3 SRGBtoLINEAR(float3 srgbIn)
{
    return pow(srgbIn, 2.2000000476837158203125f.xxx);
}

float4 avatar_finalOutputColor(avatar_FragmentInput i, avatar_FragmentOutput o)
{
    float4 color = o.color;
    if (i.debugMode == 1)
    {
        color = float4(i.material.base_color.x, i.material.base_color.y, i.material.base_color.z, float2(0.0f, 1.0f).y);
    }
    if (i.debugMode == 2)
    {
        float3 _4337 = i.material.occlusion.xxx;
        color = float4(_4337.x, _4337.y, _4337.z, color.w);
    }
    if (i.debugMode == 3)
    {
        float3 _4348 = ConvertOutputColorSpaceFromSRGB(i.material.roughness.xxx);
        color = float4(_4348.x, _4348.y, _4348.z, color.w);
    }
    if (i.debugMode == 4)
    {
        float3 _4359 = ConvertOutputColorSpaceFromSRGB(i.material.metallic.xxx);
        color = float4(_4359.x, _4359.y, _4359.z, color.w);
    }
    if (i.debugMode == 5)
    {
        float3 _4369 = i.material.thickness.xxx;
        color = float4(_4369.x, _4369.y, _4369.z, color.w);
    }
    bool _4374 = i.debugMode == 6;
    if (_4374)
    {
        color = float4(i.geometry.normal.x, i.geometry.normal.y, i.geometry.normal.z, color.w);
    }
    if (_4374)
    {
        float3 _4389 = (i.geometry.normal * 0.5f) + 0.5f.xxx;
        color = float4(_4389.x, _4389.y, _4389.z, color.w);
    }
    if (i.debugMode == 19)
    {
        float3 _4400 = (i.geometry.tangentSpace.tangent * 0.5f) + 0.5f.xxx;
        color = float4(_4400.x, _4400.y, _4400.z, color.w);
    }
    if (i.debugMode == 20)
    {
        float3 _4411 = (i.geometry.tangentSpace.bitangent * 0.5f) + 0.5f.xxx;
        color = float4(_4411.x, _4411.y, _4411.z, color.w);
    }
    if (i.debugMode == 7)
    {
    }
    if (i.debugMode == 8)
    {
    }
    if (i.debugMode == 9)
    {
        float3 world_view_dir = computeViewDir(i.geometry.camera, i.geometry.positionInWorldSpace);
        color = float4(world_view_dir.x, world_view_dir.y, world_view_dir.z, float2(0.0f, 1.0f).y);
    }
    if (i.debugMode == 10)
    {
        float3 _4443 = o.p_specular + o.p_diffuse;
        color = float4(_4443.x, _4443.y, _4443.z, color.w);
    }
    if (i.debugMode == 11)
    {
        color = float4(o.p_specular.x, o.p_specular.y, o.p_specular.z, color.w);
    }
    if (i.debugMode == 12)
    {
        color = float4(o.p_diffuse.x, o.p_diffuse.y, o.p_diffuse.z, color.w);
    }
    if (i.debugMode == 13)
    {
        float3 _4469 = o.a_specular + o.a_diffuse;
        color = float4(_4469.x, _4469.y, _4469.z, color.w);
    }
    if (i.debugMode == 14)
    {
        color = float4(o.a_specular.x, o.a_specular.y, o.a_specular.z, color.w);
    }
    if (i.debugMode == 15)
    {
        color = float4(o.a_diffuse.x, o.a_diffuse.y, o.a_diffuse.z, color.w);
    }
    if (i.debugMode == 16)
    {
    }
    if (i.debugMode == 17)
    {
        color = float4(o.subSurfaceColor.x, o.subSurfaceColor.y, o.subSurfaceColor.z, color.w);
    }
    if (i.debugMode == 18)
    {
        float subMeshId = i.material.alpha;
        color = float4(0.0f.xxx.x, 0.0f.xxx.y, 0.0f.xxx.z, color.w);
        if (avatar_IsOfType(subMeshId, 0.00390625f))
        {
            color = float4(0.20000000298023223876953125f.xxx.x, 0.20000000298023223876953125f.xxx.y, 0.20000000298023223876953125f.xxx.z, color.w);
        }
        if (avatar_IsOfType(subMeshId, 0.0078125f))
        {
            color = float4(float3(0.769999980926513671875f, 0.64999997615814208984375f, 0.64999997615814208984375f).x, float3(0.769999980926513671875f, 0.64999997615814208984375f, 0.64999997615814208984375f).y, float3(0.769999980926513671875f, 0.64999997615814208984375f, 0.64999997615814208984375f).z, color.w);
        }
        if (avatar_IsOfType(subMeshId, 0.015625f))
        {
            color = float4(float3(0.769999980926513671875f, 0.64999997615814208984375f, 0.64999997615814208984375f).x, float3(0.769999980926513671875f, 0.64999997615814208984375f, 0.64999997615814208984375f).y, float3(0.769999980926513671875f, 0.64999997615814208984375f, 0.64999997615814208984375f).z, color.w);
        }
        if (avatar_IsOfType(subMeshId, 0.03125f))
        {
            color = float4(float3(0.3449999988079071044921875f, 0.2700000107288360595703125f, 0.10999999940395355224609375f).x, float3(0.3449999988079071044921875f, 0.2700000107288360595703125f, 0.10999999940395355224609375f).y, float3(0.3449999988079071044921875f, 0.2700000107288360595703125f, 0.10999999940395355224609375f).z, color.w);
        }
        if (avatar_IsOfType(subMeshId, 0.0625f))
        {
            color = float4(float3(0.23999999463558197021484375f, 0.189999997615814208984375f, 0.07999999821186065673828125f).x, float3(0.23999999463558197021484375f, 0.189999997615814208984375f, 0.07999999821186065673828125f).y, float3(0.23999999463558197021484375f, 0.189999997615814208984375f, 0.07999999821186065673828125f).z, color.w);
        }
        if (avatar_IsOfType(subMeshId, 0.125f))
        {
            color = float4(float3(0.0f, 0.0f, 1.0f).x, float3(0.0f, 0.0f, 1.0f).y, float3(0.0f, 0.0f, 1.0f).z, color.w);
        }
        if (avatar_IsOfType(subMeshId, 0.25f))
        {
            color = float4(float3(0.0f, 1.0f, 0.0f).x, float3(0.0f, 1.0f, 0.0f).y, float3(0.0f, 1.0f, 0.0f).z, color.w);
        }
        if (avatar_IsOfType(subMeshId, 0.5f))
        {
            color = float4(float3(0.5f, 0.0f, 0.0f).x, float3(0.5f, 0.0f, 0.0f).y, float3(0.5f, 0.0f, 0.0f).z, color.w);
        }
        if (avatar_IsOfType(subMeshId, 1.0f))
        {
            color = float4(float3(0.20000000298023223876953125f, 0.100000001490116119384765625f, 0.0500000007450580596923828125f).x, float3(0.20000000298023223876953125f, 0.100000001490116119384765625f, 0.0500000007450580596923828125f).y, float3(0.20000000298023223876953125f, 0.100000001490116119384765625f, 0.0500000007450580596923828125f).z, color.w);
        }
        if (avatar_IsOfType(subMeshId, 2.0f))
        {
            color = float4(0.100000001490116119384765625f.xxx.x, 0.100000001490116119384765625f.xxx.y, 0.100000001490116119384765625f.xxx.z, color.w);
        }
        if (avatar_IsOfType(subMeshId, 4.0f))
        {
            color = float4(1.0f.xxx.x, 1.0f.xxx.y, 1.0f.xxx.z, color.w);
        }
    }
    return color;
}

void frag_Fragment_main()
{
    avatar_FragmentInput i = avatar_zeroFragmentInput();
    i.options = getFragOptions(v_Color.w);
    i.debugMode = Debug;
    int lightCount = getLightCount();
    i.lightsCount = lightCount;
    i.lights[0].intensity = 1.0f;
    i.lights[0].direction = getLightDirection();
    i.lights[0].color = getLightColor();
    i.lights[0].position = getLightPosition();
    i.lights[0].type = 0;
    i.lights[0].range = 1000.0f;
    i.lights[0].innerConeCos = 0.0f;
    i.lights[0].outerConeCos = 0.0f;
    avatar_Light avatarLight;
    for (int idx = 1; idx < 8; idx++)
    {
        if (idx < lightCount)
        {
            OvrLight ovrLight = getAdditionalLight(idx, v_WorldPos);
            avatarLight.direction = -ovrLight.direction;
            avatarLight.intensity = 1.0f;
            avatarLight.color = ovrLight.color;
            avatarLight.position = ovrLight.direction;
            avatarLight.type = 0;
            avatarLight.range = 100.0f;
            avatarLight.innerConeCos = 0.0f;
            avatarLight.outerConeCos = 0.0f;
            i.lights[idx] = avatarLight;
        }
    }
    i.geometry.camera = _WorldSpaceCameraPos;
    i.geometry.positionInWorldSpace = v_WorldPos;
    i.geometry.positionInClipSpace = v_Vertex.xyz / v_Vertex.w.xxx;
    i.geometry.texcoord_0 = v_UVCoord1;
    i.geometry.texcoord_1 = v_UVCoord2;
    i.geometry.normalScale = u_NormalScale;
    i.geometry.tangentSpace.normal = normalize(v_Normal);
    i.geometry.tangentSpace.tangent = normalize(v_Tangent.xyz);
    i.geometry.tangentSpace.bitangent = calculateBitangent(i.geometry.tangentSpace);
    i.geometry.normal = i.geometry.tangentSpace.normal;
    bool _return = false;
    float3 _returnValue;
    if (!i.options.enableNormalMapping)
    {
        _return = true;
        _returnValue = i.geometry.normal;
    }
    if (!_return)
    {
        float3 shadingNormal = float3(((tex2D(u_NormalSampler, i.geometry.texcoord_0) * 2.0f) - 1.0f.xxxx).xy, 1.0f);
        shadingNormal *= float3(i.geometry.normalScale, i.geometry.normalScale, 1.0f);
        _return = true;
        _returnValue = mul(normalize(shadingNormal), float3x3(i.geometry.tangentSpace.tangent, i.geometry.tangentSpace.bitangent, i.geometry.tangentSpace.normal));
    }
    i.geometry.normal = _returnValue;
    i.geometry.color = v_Color;
    i.geometry.ormt = v_ORMT;
    i.material.base_color = StaticSelectMaterialModeColor(u_BaseColorSampler, i.geometry.texcoord_0, float4(i.geometry.color.x, i.geometry.color.y, i.geometry.color.z, float2(0.0f, 1.0f).y)).xyz;
    i.material.ramp_selector = 1.0f - (float(u_RampSelector) / 45.0f);
    i.material.color_selector_lod = 0;
    bool _return_1 = false;
    float3 _returnValue_1;
    if (i.options.enablePreviewColorRamp)
    {
        float2 rampCoord = float2(LINEARtoSRGB(i.material.base_color.x), i.material.ramp_selector);
        _return_1 = true;
        _returnValue_1 = tex2Dlod(u_ColorGradientSampler, float4(rampCoord, 0.0, float(i.material.color_selector_lod))).xyz;
    }
    if (!_return_1)
    {
        _return_1 = true;
        _returnValue_1 = i.material.base_color;
    }
    i.material.base_color = _returnValue_1;
    i.material.alpha = i.geometry.color.w;
    float4 ormt = StaticSelectMaterialModeColor(u_MetallicRoughnessSampler, i.geometry.texcoord_0, i.geometry.ormt);
    float _5058 = ormt.x;
    i.material.occlusion = lerp(1.0f, _5058, u_OcclusionStrength);
    float _5063 = ormt.y;
    i.material.roughness = _5063 * u_RoughnessFactor;
    float _5068 = ormt.z;
    i.material.metallic = _5068 * u_MetallicFactor;
    i.material.ambient_diffuse_factor = 1.0f;
    i.material.ambient_specular_factor = 1.0f;
    i.ambient_color = v_SH;
    float _5077 = ormt.w;
    i.material.thickness = _5077 * u_ThicknessFactor;
    i.material.thickness = u_ThicknessFactor;
    if (i.options.enableSkin)
    {
        i.material.occlusion *= u_SkinORMFactor.x;
        i.material.roughness *= u_SkinORMFactor.y;
        i.material.metallic *= u_SkinORMFactor.z;
    }
    i.material.hair_material.subsurface_color = u_HairSubsurfaceColor;
    i.material.hair_material.scatter_intensity = u_HairScatterIntensity;
    i.material.hair_material.specular_color_factor = u_HairSpecularColorFactor;
    i.material.hair_material.specular_shift_intensity = u_HairSpecularShiftIntensity;
    i.material.hair_material.specular_white_intensity = u_HairSpecularWhiteIntensity;
    i.material.hair_material.specular_white_roughness = u_HairRoughness;
    i.material.hair_material.specular_color_intensity = u_HairSpecularColorIntensity;
    i.material.hair_material.specular_color_offset = u_HairSpecularColorOffset;
    i.material.hair_material.specular_color_roughness = u_HairColorRoughness;
    i.material.hair_material.anisotropic_intensity = u_HairAnisotropicIntensity;
    i.material.hair_material.diffused_intensity = u_HairDiffusedIntensity;
    i.material.hair_material.normal_intensity = u_HairSpecularNormalIntensity;
    i.material.hair_material.specular_glint = u_HairSpecularGlint;
    i.material.hair_material.ao_intensity = _5058;
    i.material.hair_material.flow_angle = (_5063 - 0.5f) * 6.283185482025146484375f;
    i.material.hair_material.shift = _5068;
    i.material.hair_material.blend = _5077;
    i.material.rim_light_material.intensity = u_RimLightIntensity;
    i.material.rim_light_material.bias = u_RimLightBias;
    i.material.rim_light_material.color = u_RimLightColor;
    i.material.rim_light_material.transition = u_RimLightTransition;
    i.material.rim_light_material.start = u_RimLightStartPosition;
    i.material.rim_light_material.end = u_RimLightEndPosition;
    i.material.exposure = u_Exposure;
    i.material.skin.subsurface_color = u_SubsurfaceColor;
    i.material.skin.skin_ORM_factor = u_SkinORMFactor;
    i.material.eye_glint_factor = u_EyeGlintFactor;
    i.material.eye_glint_color_factor = u_EyeGlintColorFactor;
    i.matrices.objectToWorld = unity_ObjectToWorld;
    i.matrices.worldToObject = float3x3(unity_WorldToObject[0].xyz, unity_WorldToObject[1].xyz, unity_WorldToObject[2].xyz);
    i.geometry.worldViewDir = computeViewDir(i.geometry.camera, i.geometry.positionInWorldSpace);
    float mipCount = 1.0f * float(u_MipCount);
    i.geometry.lod = clamp(i.material.roughness * mipCount, 0.0f, mipCount);
    AppSpecificPreManipulation(i);
    float3 punctualDiffuseWrap = 0.0f.xxx;
    float3 rimLight = 0.0f.xxx;
    avatar_FragmentOutput o_1 = avatar_zeroFragmentOutput();
    for (int lightIdx = 0; lightIdx < 8; lightIdx++)
    {
        if (lightIdx < i.lightsCount)
        {
            avatar_Light light = i.lights[lightIdx];
            if (!i.options.enableEyeGlint)
            {
                o_1.p_specular += avatar_computeSpecular(i.geometry, light, i.material, i.options);
            }
            float3 diffuseWrap = 0.0f.xxx;
            float3 _5389 = avatar_computeDiffuse(i.geometry, light, i.material, diffuseWrap);
            o_1.p_diffuse += _5389;
            punctualDiffuseWrap += diffuseWrap;
        }
        if (i.options.enableShadows)
        {
            o_1.p_diffuse *= i.lights[0].shadowTerm;
            o_1.p_specular *= i.lights[0].shadowTerm;
            punctualDiffuseWrap *= i.lights[0].shadowTerm;
        }
    }
    if ((i.options.enableEyeGlint && (!i.options.enableSkin)) && (!i.options.enableHair))
    {
        o_1.p_specular += 0.0f.xxx;
    }
    float3 diffuse = 0.0f.xxx;
    float3 _5511 = -i.geometry.worldViewDir;
    float _5516 = 1.0f - i.material.roughness;
    OvrGetUnityDiffuseGlobalIllumination(i.lights[0].color, i.lights[0].direction, i.geometry.positionInWorldSpace, _5511, 1.0f, i.ambient_color, _5516, i.material.metallic, i.material.occlusion, i.material.base_color, i.geometry.normal, 0.0f.xxx, diffuse);
    avatar_AmbientLighting ambient;
    ambient.diffuse = diffuse;
    float3 diffuse0 = 0.0f.xxx;
    float3 specular = 0.0f.xxx;
    OvrGetUnityGlobalIllumination(i.lights[0].color, i.lights[0].direction, i.geometry.positionInWorldSpace, _5511, 1.0f, i.ambient_color, _5516, i.material.metallic, i.material.occlusion, i.material.base_color, i.geometry.normal, o_1.p_specular, diffuse0, specular);
    ambient.specular = specular;
    float hairBlend = 0.0f;
    float3 totalhairPunctualSpec = 0.0f.xxx;
    float3 specularFactor = lerp((0.039999999105930328369140625f + ((lerp(1.0f, 0.039999999105930328369140625f, sqrt(i.material.roughness)) - 0.039999999105930328369140625f) * saturate(pow(1.0f - computeNdotV(i.geometry.normal, i.geometry.worldViewDir), 5.0f)))).xxx, i.material.base_color, i.material.metallic.xxx) * i.material.occlusion;
    if (!i.options.enableEyeGlint)
    {
        o_1.p_specular *= specularFactor;
    }
    o_1.a_specular = (specularFactor * i.material.ambient_specular_factor) * ambient.specular;
    if (i.options.enableHair)
    {
        hairBlend = i.material.hair_material.blend;
        avatar_HairMaterial hair_mat = i.material.hair_material;
        float2 flow = float2(cos(hair_mat.flow_angle), sin(hair_mat.flow_angle));
        float3 hairTangent = (i.geometry.tangentSpace.tangent * flow.x) + (i.geometry.tangentSpace.bitangent * flow.y);
        float3 hairTangent2 = normalize(hairTangent);
        float3 hairNormal = lerp(i.geometry.tangentSpace.normal, i.geometry.normal, i.material.hair_material.normal_intensity.xxx);
        float3x3 hairCoordinateSystem = float3x3(hairNormal, hairTangent2, normalize(cross(hairNormal, hairTangent2)));
        for (int lightIdx_1 = 0; lightIdx_1 < 8; lightIdx_1++)
        {
            if (lightIdx_1 < i.lightsCount)
            {
                avatar_Light light_1 = i.lights[lightIdx_1];
                float3 directional_light_color = ((light_1.color * (1.0f / i.material.exposure)) * 0.3183098733425140380859375f) * light_1.intensity;
                totalhairPunctualSpec += ((computeHairSpecular(i, light_1.direction, hairCoordinateSystem, i.material.hair_material.aniso_blend) * directional_light_color) * 0.3183098733425140380859375f);
            }
        }
        o_1.p_specular = blendPunctualSpecularWithHair(o_1.p_specular, totalhairPunctualSpec, hairBlend);
        o_1.subSurfaceColor = blendSubSurfaceColorWithHair(i.material.hair_material.subsurface_color, float3(1.0f, 0.300000011920928955078125f, 0.20000000298023223876953125f), hairBlend);
        o_1.a_specular *= (1.0f - hairBlend);
        o_1.p_diffuse *= lerp(1.0f, i.material.hair_material.diffused_intensity, hairBlend);
    }
    avatar_FragmentOutput _5442 = o_1;
    if (i.options.enableSkin)
    {
        o_1.p_diffuse = (punctualDiffuseWrap * float3(1.0f, 0.300000011920928955078125f, 0.20000000298023223876953125f)) + (_5442.p_diffuse * (1.0f.xxx - float3(1.0f, 0.300000011920928955078125f, 0.20000000298023223876953125f)));
        float3 subsurfaceColor = 0.0f.xxx;
        float3 diffuse_1 = 0.0f.xxx;
        float3 accumulatedDiffuseColor = 0.0f.xxx;
        avatar_HemisphereNormalOffsets hemisphereNormalOffsets = avatar_computeHemisphereNormalOffsets(i);
        float3 diffuse_2 = 0.0f.xxx;
        OvrGetUnityDiffuseGlobalIllumination(i.lights[0].color, i.lights[0].direction, i.geometry.positionInWorldSpace, -i.geometry.worldViewDir, 1.0f, i.ambient_color, 1.0f - i.material.roughness, i.material.metallic, i.material.occlusion, i.material.base_color, hemisphereNormalOffsets.lv1, 0.0f.xxx, diffuse_2);
        float3 ibl_diffuse1 = saturate(diffuse_2);
        float3 diffuse_3 = 0.0f.xxx;
        OvrGetUnityDiffuseGlobalIllumination(i.lights[0].color, i.lights[0].direction, i.geometry.positionInWorldSpace, -i.geometry.worldViewDir, 1.0f, i.ambient_color, 1.0f - i.material.roughness, i.material.metallic, i.material.occlusion, i.material.base_color, hemisphereNormalOffsets.lv2, 0.0f.xxx, diffuse_3);
        float3 ibl_diffuse2 = saturate(diffuse_3);
        float3 diffuse_4 = 0.0f.xxx;
        OvrGetUnityDiffuseGlobalIllumination(i.lights[0].color, i.lights[0].direction, i.geometry.positionInWorldSpace, -i.geometry.worldViewDir, 1.0f, i.ambient_color, 1.0f - i.material.roughness, i.material.metallic, i.material.occlusion, i.material.base_color, hemisphereNormalOffsets.lv3, 0.0f.xxx, diffuse_4);
        float3 ibl_diffuse3 = saturate(diffuse_4);
        float3 diffuse_5 = 0.0f.xxx;
        OvrGetUnityDiffuseGlobalIllumination(i.lights[0].color, i.lights[0].direction, i.geometry.positionInWorldSpace, -i.geometry.worldViewDir, 1.0f, i.ambient_color, 1.0f - i.material.roughness, i.material.metallic, i.material.occlusion, i.material.base_color, hemisphereNormalOffsets.nn, 0.0f.xxx, diffuse_5);
        float3 ibl_diffuseN = saturate(diffuse_5);
        for (int lightIdx_2 = 0; lightIdx_2 < 8; lightIdx_2++)
        {
            if (lightIdx_2 < i.lightsCount)
            {
                float3 worldSpaceLightDir = -i.lights[lightIdx_2].direction;
                float3 lightColor = (i.lights[lightIdx_2].color * i.lights[lightIdx_2].intensity) * (1.0f / 3.1415927410125732421875f);
                float3 directionalLightColor = lightColor * (1.0f / i.material.exposure);
                float directionalSoftDiffuseValue = (saturate(dot(worldSpaceLightDir, hemisphereNormalOffsets.lv1)) + saturate(dot(worldSpaceLightDir, hemisphereNormalOffsets.lv2))) + saturate(dot(worldSpaceLightDir, hemisphereNormalOffsets.lv3));
                diffuse_1 += (directionalSoftDiffuseValue.xxx * directionalLightColor);
                accumulatedDiffuseColor += (directionalLightColor * saturate(dot(worldSpaceLightDir, hemisphereNormalOffsets.nn)));
            }
        }
        float3 softDiffuseLight = (((ibl_diffuse1 + ibl_diffuse2) + ibl_diffuse3) + diffuse_1) * 0.3333333432674407958984375f;
        subsurfaceColor = ((softDiffuseLight * float3(1.0f, 0.300000011920928955078125f, 0.20000000298023223876953125f)) * saturate(i.material.occlusion + 0.4000000059604644775390625f)) + (((accumulatedDiffuseColor + ibl_diffuseN) * (1.0f.xxx - float3(1.0f, 0.300000011920928955078125f, 0.20000000298023223876953125f))) * i.material.occlusion);
        o_1.subSurfaceColor = subsurfaceColor;
        o_1.subSurfaceColor -= (o_1.p_diffuse * i.material.occlusion);
        o_1.subSurfaceColor = saturate(o_1.subSurfaceColor);
    }
    float3 diffuseFactor = i.material.base_color * (i.material.occlusion * (1.0f - i.material.metallic));
    o_1.p_diffuse = diffuseFactor * o_1.p_diffuse;
    o_1.a_diffuse = (diffuseFactor * i.material.ambient_diffuse_factor) * ambient.diffuse;
    o_1.subSurfaceColor *= i.material.base_color;
    if (i.options.enableRimLight)
    {
        rimLight = 0.0f.xxx + avatar_addRimLight(i.geometry, i.material);
    }
    float3 finalColor_1 = ((((0.0f.xxx + (o_1.p_diffuse + o_1.a_diffuse)) + rimLight) + (_5442.p_specular + _5442.a_specular)) + o_1.subSurfaceColor) * i.material.exposure;
    o_1.color = float4(finalColor_1.x, finalColor_1.y, finalColor_1.z, o_1.color.w);
    o_1.color.w = 1.0f;
    avatar_FragmentOutput o = o_1;
    o.color = float4(o_1.color.xyz.x, o_1.color.xyz.y, o_1.color.xyz.z, o.color.w);
    o.alphaCoverage = avatar_calculateAlphaCoverage(i, i.geometry.positionInClipSpace);
    AppSpecificPostManipulation(i, o);
    float4 finalColor = float4(o.color.x, o.color.y, o.color.z, float2(0.0f, 1.0f).y);
    if (i.options.enableDebugRender)
    {
        finalColor = avatar_finalOutputColor(i, o);
    }
    float4 _5191 = finalColor;
    finalColor = float4(_5191.xyz.x, _5191.xyz.y, _5191.xyz.z, _5191.w);
    _21 = float4(_5191.xyz.x, _5191.xyz.y, _5191.xyz.z, _5191.w);
}

FragmentOutput Fragment_main(VertexToFragment stage_input)
{
    v_Vertex = stage_input.v_Vertex;
    v_WorldPos = stage_input.v_WorldPos;
    v_Normal = stage_input.v_Normal;
    v_Tangent = stage_input.v_Tangent;
    v_UVCoord1 = stage_input.v_UVCoord1;
    v_UVCoord2 = stage_input.v_UVCoord2;
    v_Color = stage_input.v_Color;
    v_ORMT = stage_input.v_ORMT;
    v_SH = stage_input.v_SH;
    frag_Fragment_main();
    FragmentOutput stage_output;
    stage_output._21 = float4(_21);
    return stage_output;
}

// Generated by AvatarShaderLibrary 242d0d331a49

